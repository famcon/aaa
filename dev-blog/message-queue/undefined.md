# 메시지 큐 비교

## 메시지 큐

메시지 큐는 데이터를 비동기로 처리하기 위한 시스템입니다.

Producer가 메시지를 생성하고 큐에 보내면 Queue는 메시지를 저장해두었다가 Consumer가 메시지 요청하면 전달해주는 중간저장소 역할을 합니다.

### 기능

* 비동기처리 : 메시지는 큐에 저장되어 즉시 처리하지 않고 지정한 지연시간 뒤에 처리될 수 있어 시스템을 비동기로 동작할 수 있게 끔 합니다.
* 메시지 보장: 메시지큐에 전송된 메시지는 손실되지 않도록 보장하고, 중복방지나 재시도 매커니즘을 제공합니다.
* 로드 밸런싱: 소비자가 확장되면 메시지를 분산시켜 부하를 분산시킬 수 있습니다.
* 스케일링: 큐를 중간저장소로 두기 때문에 생산자오 소비자 수를 독립적으로 조절할 수 있습니다.

### 사용 사례

* 비동기 처리: 예약이 발생했을 때 즉시 알림을 보내지 않고 이벤트를 등록한 뒤 알림 시스템에서 메시지를 수신해서 처리
* 로깅: 로그데이터를 수집하고 분석시스템으로 전달
* 작업 분산: 대량의 작업을 여러 시스템으로 분산해서 병렬로 처리



## 시스템

메시지 큐 시스템은 대표적으로 카프카, 래빗엠큐, 레디스, SQS가 있습니다.

### 비교

저는 신규 프로젝트를 세팅하면서 비동기 처리를 위해 AWS MSK(kafka)를 구축했었는데요.

처음에는 저희 회사의 데이터가 모두 지나다니는 데이터허브가 되기를 기대하면서 Kafka를 선택했는데, 여러가지 상황상 오버엔지니어링이라는 생각이 들었고 SQS로 교체하게 되었습니다.

다행히 제품 출시 전 개발 중반 단계에서 빠르게 교체를 결정했고, 또 애플리케이션 코드에서 메시지 큐 시스템을 추상화하여 사용하고 있었기 때문에 교체에 큰 어려움이 없었습니다.

다음은 제가 MSK -> SQS로 상황에 따라 적절한 메시지 큐 시스템을 선택할 때 참고하기 위해 정리한 내용입니다.

* 높은 성능
  * Kafka: 높은 처리량과 내구성을 가지고 있음, 1,000,000+ 메시지/초
  * RabbitMQ: 10,000 - 100,000 메시지/초 (대규모 클러스터링 시)
  * Redis: 1,000,000+ 메시지/초 (메모리 기반 처리로 높은 성능)
* 안정성
  * Kafka: 높은 내구성, 복제 지원
  * RabbitMQ: 높은 내구성, 복제 지원
  * SQS: 클라우드 기반 서버리스 아키텍처, S3와 통합
* 메시지 순서 보장
  * SQS: FIFO 대기열을 사용
  * RabbitMQ: 큐 내에서 순서 보장
* 이벤트 처리
  * Kafka: 각 소비자가 같은 이벤트를 독립적으로 처리 가능
  * RabbitMQ: 메시지 라우팅
  * Redis: pub/sub 기능 지원
* 저비용
  * SQS: 클라우드 기반 서버리스 아키텍처
  * Redis: 기존에 이용하고 있고, 오래 관리해왔다면 설정 및 유지관리 비용 낮음
* 메시지 크기
  * Kafka: 기본 1MB고 10GB 까지 조절가능
  * Redis: 기본 512MB이고 Redis Streams 사용하면 더 크게 지원가능
  * RabbitMQ: 기본 64MB고 최대 128MB까지 조절가능
* 확장성
  * Kafka: 수평 확장성 우수(파티션 쪼개기), 단 스케일 인 안됨
  * SQS: 자동 확장

제가 맡은 신규프로젝트의 개발 초반에는 확장성과 안정성을 비동기 시스템에 필요한 원칙으로 정의했고, 이에 Kafka와 SQS 두 개가 선택됐습니다. 개발 기한을 길게 받아서, 리서치하며 모니터링도 구축하고 페일오버 테스트도 해볼 수 있을 것 같아 Kafka를 선택했는데요.

하지만 개발 중반에 여러가지 상황이 겹치면서 급격하게 기한이 줄어들었고, 이에 저비용 원칙이 추가되며 SQS로 교체하게 되었습니다.



### 요약

위의 자료만으로는 적절한 메시지 큐 시스템을 선택하기 어려울 수 있으므로, 각 시스템별로 리서치한 내용을 조금만 더 요약해보겠습니다.

#### Apache Kafka

카프카는 링크드인에서 개발했고, 현재는 아파치 재단의 프로젝트로 관리되고 있습니다.

고속 데이터 처리와 높은 내결함성을 제공하고, 대용량 데이터의 실시간 스트리밍에 최적화 되어있습니다.

구성요소

* **Producer**: 데이터를 생성하고 Kafka에 전송하는 역할을 합니다.
* **Broker**: Kafka 클러스터의 서버로, 데이터를 저장하고 전달하는 역할을 합니다.
* **Topic**: 데이터가 게시되는 카테고리로, 여러 프로듀서가 같은 토픽에 데이터를 게시할 수 있습니다.
* **Partition**: 각 토픽은 여러 파티션으로 나뉘어 있으며, 각 파티션은 독립적인 로그를 가지고 있습니다.
* **Consumer**: 토픽의 데이터를 읽고 처리하는 역할을 합니다.

장점

* **고속 처리 및 높은 성능:** 높은 처리량과 낮은 지연 시간으로 실시간 데이터 스트리밍을 지원합니다. 데이터는 여러 파티션에 분산되어 저장되며, 이를 통해 대량의 데이터를 효율적으로 처리할 수 있습니다.
* **확장성:** 추가적인 브로커를 클러스터에 추가함으로써 쉽게 성능을 확장할 수 있으며, 파티션을 추가하여 처리량을 증가시킬 수 있습니다.
* **내결함성:** 복제 기능을 통해 데이터의 내결함성을 보장합니다. 각 파티션의 데이터는 여러 브로커에 복제되어 저장되므로, 브로커가 실패하더라도 데이터 손실 없이 서비스를 계속 제공할 수 있습니다.
* **내구성:** 데이터를 디스크에 기록하고, 이를 지속적으로 유지하여 높은 내구성을 제공합니다.&#x20;
* **이벤트 브로커:** pub/sub을 지원하여 소비자는 독립적으로 데이터를 읽을 수 있습니다. 이를 통해 다양한 소비자 그룹이 동일한 데이터를 처리할 수 있습니다.

단점

* **복잡한 설정 및 관리:** 설정과 운영이 복잡합니다. 클러스터의 규모가 커질수록 관리와 모니터링이 어렵고, Zookeeper와의 연동 등 다양한 구성 요소를 관리해야 합니다.
* **자원 소모:** 높은 성능을 제공하기 위해 많은 자원을 소모하고, 특히  디스크 I/O와 메모리 사용량이 많아, 높은 유형의 하드웨어 자원이 필요할 수 있습니다.
* **기본적인 메시지 순서 보장:** 파티션 내에서 메시지 순서를 보장하지만, 파티션 간에는 순서가 보장되지 않습니다. 따라서 순서가 중요한 메시지의 경우 그냥(?) 다른 시스템을 쓰는게 더 좋다고 합니다.

#### RabbitMQ

오픈소스 메시지 브로커로 다양한 매시징패턴을 지원합니다.

구성요소

* **Producer**: 메시지를 생성하고 RabbitMQ에 보냅니다.
* **Exchange**: 메시지를 수신하고 적절한 큐에 라우팅하는 역할을 합니다.
* **Queue**: 메시지를 저장하고, 소비자가 큐에서 메시지를 읽어 처리합니다.
* **Consumer**: 큐에서 메시지를 읽고 처리합니다.
* **Binding**: Exchange와 큐 간의 연결을 정의하는 규칙입니다.

장점

* **풍부한 메시징 패턴 지원:** Pub/Sub(퍼블리시/구독), Work Queues(작업 큐), Routing(라우팅), Topic Exchanges(토픽 교환) 등 다양한 패턴을 지원한다고 합니다.
* **신뢰성과 내결함성:** 메시지 내구성, 큐 내구성, 메시지 확인(acknowledgment), 재전송(retry) 등의 기능을 통해 높은 신뢰성과 내결함성을 제공합니다. 메시지는 디스크에 기록되어 서버가 재시작되더라도 데이터 손실이 없습니다.
* **유연한 라우팅:** Exchange와 Binding을 사용하면 복잡한 라우팅 로직을 구성할 수 있습니다. 이를 통해 메시지를 효율적으로 라우팅하고 다양한 소비자 그룹에게 전달할 수 있습니다.
* **관리 및 모니터링:** 직관적인 웹 기반 관리 대시보드를 제공합니다.

단점

* **성능 한계:** 대규모 데이터 스트리밍이나 실시간 데이터 처리가 필요한 경우 성능이 제한될 수 있습니다.
* **관리 복잡성**: kafka보다는 설정이 비교적 간단하지만, 다른 시스템에 비해 관리가 어려울 수 있습니다.

#### SQS

AWS에서 제공하는 완전 관리형 메시지 큐 서비스입니다.

SQS는 두 가지 주요 큐 유형을 제공합니다:

1. **표준 큐**: 높은 처리량과 대기 시간 없이 메시지를 신속하게 전송할 수 있으며, 메시지 순서 보장이 필요 없는 경우에 적합
2. **FIFO (First-In-First-Out) 큐**: 메시지 순서를 보장하며 메시지 중복을 방지, 순서와 중복 처리가 중요한 애플리케이션에 적합

장점

* **완전 관리형 서비스:** 서버 관리나 유지보수 부담이 없어서 사용자는 메시지 큐의 생성과 관리에 집중할 수 있습니다. 또한 자동으로 확장되며, 메시지 수와 처리량에 따라 필요한 자원을 자동으로 조절합니다.
* **높은 내구성**: 메시지가 100% 안전하게 저장디고 S3와 통합하여 메시지의 내구성을 더욱 강화할 수 있습니다.
* **비용 효율성**: 사용한 만큼 지불하는 방식으로, 초당 요청 수와 전송된 메시지 수에 따라 요금이 부과됩니다. 초과 용량에 대해 별도로 지불할 필요가 없습니다.
* **보안**: 메시지를 전송할 때와 저장할 때 암호화를 지원합니다. AWS Key Management Service (KMS)를 통해 데이터를 안전하게 보호할 수 있습니다. 그리고 IAM와 통합되어, 메시지 큐에 대한 액세스를 세밀하게 제어할 수 있습니다.
* **유연한 메시지 처리**: 메시지의 최대 생명 주기를 설정할 수 있어, 특정 시간 이후에 자동으로 삭제되도록 할 수 있고 메시지를 일정 시간 동안 지연시킬 수 있어, 일정 시간이 지난 후에만 처리가 필요할 때 유용합니다.

단점

* **메시지 크기 제한**: 최대 메시지 크기는 256KB로 제한되어 있습니다. 큰 데이터나 파일을 전송하려면 S3와 통합하여 처리해야 합니다.
* **기본 메시지 순서 보장 부족**: 표준 큐는 메시지 순서를 보장하지 않으며, FIFO 큐를 사용해야 순서 보장이 가능합니다. FIFO 큐는 처리량이 표준 큐에 비해 낮습니다.
* **메시지 처리 지연**: 약간의 지연이 발생할 수 있습니다.
* **복잡한 메시지 흐름 관리**: 복잡한 메시지 흐름이나 많은 수의 큐를 관리해야 하는 경우, 큐 간의 상호작용 및 흐름을 제어하는 것이 복잡할 수 있습니다.
* **제한된 메시지 우선순위**: 메시지 우선순위를 지원하지 않으므로, 특정 메시지의 우선순위를 설정하여 처리할 수 없습니다.

#### Redis

오픈 소스 인메모리 데이터 구조 서버로, 다양한 데이터 구조를 지원하며 매우 빠른 읽기 및 쓰기 성능을 제공합니다. 주로 캐싱, 세션 저장소, 실시간 데이터 분석 및 메시지 브로커로 사용됩니다. 데이터는 메모리에 저장되며, 디스크에 비동기적으로 저장하여 데이터 영속성을 보장할 수 있습니다.

장점

* **높은 성능**: 메모리 기반의 데이터 구조 서버로, 매우 낮은 지연 시간과 높은 처리량을 제공합니다.
* **다양한 데이터 구조 지원**: Redis는 문자열, 해시, 리스트, 셋, 정렬된 셋 등 다양한 데이터 구조를 지원합니다. 이를 통해 다양한 데이터 처리 요구 사항을 충족할 수 있습니다. 또한 Redis Streams와 Pub/Sub 기능을 통해 실시간 데이터 스트리밍과 메시지 브로커 역할을 수행할 수 있습니다.
* **다양한 클라우드 지원**: AWS의 Amazon ElastiCache, Microsoft Azure의 Azure Cache for Redis, Google Cloud의 Memorystore와 같은 관리형 Redis 서비스를 통해 클라우드 환경에서도 쉽게 사용할 수 있습니다.

단점

* **메모리 기반 저장:** 메모리 기반으로 작동하므로, 메모리 용량이 제한적입니다. 대량의 데이터를 처리할 때 메모리 용량 부족 문제가 발생할 수 있습니다.
* **메시지 크기 제한**: 최대 메시지 크기는 기본적으로 512MB로 설정되어 있으며, Redis Streams를 사용할 경우 더 큰 메시지 크기를 지원할 수 있지만, 메모리 기반이므로 매우 큰 데이터 처리에 제약이 있을 수 있습니다.
* **데이터 영속성 관련 제약**: 영속성 옵션은 메모리 기반으로 인한 성능 영향을 줄 수 있습니다. 디스크 I/O와 관련된 설정이 필요하며, 영속성 설정에 따라 성능과 안정성의 트레이드오프가 발생할 수 있습니다.
* **메시지 순서 보장 부족**: Redis의 기본 Pub/Sub 메커니즘은 메시지 순서를 보장하지 않습니다. 순서 보장이 필요한 경우 Redis Streams를 사용해야 하며, 이 또한 메모리 기반의 제약이 있습니다.





